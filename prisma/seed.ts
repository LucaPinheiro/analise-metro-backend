import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';

const prisma = new PrismaClient();

/**
 * Script de Seed - Popular banco de dados com dados mock
 * 
 * Uso:
 *   npx tsx prisma/seed.ts
 *   ou
 *   npm run seed
 */

// Dados mock para projetos
const mockProjects = [
    {
        name: 'EstaÃ§Ã£o Morumbi - Bloco A',
        description: 'Bloco A da estaÃ§Ã£o Morumbi da linha 4-Amarela',
        bimPath: 'projects/seed/estacao_morumbi_bloco_a.ifc'
    },
    {
        name: 'EstaÃ§Ã£o ButantÃ£ - Plataforma Central',
        description: 'Plataforma central da estaÃ§Ã£o ButantÃ£',
        bimPath: 'projects/seed/estacao_butanta_plataforma.obj'
    },
    {
        name: 'EstaÃ§Ã£o Pinheiros - Acesso Norte',
        description: 'Acesso norte da estaÃ§Ã£o Pinheiros',
        bimPath: 'projects/seed/estacao_pinheiros_acesso_norte.dwg'
    },
    {
        name: 'EstaÃ§Ã£o Fradique Coutinho - Estrutura',
        description: 'Estrutura principal da estaÃ§Ã£o Fradique Coutinho',
        bimPath: 'projects/seed/estacao_fradique_estrutura.ifc'
    },
    {
        name: 'EstaÃ§Ã£o Faria Lima - Bloco Sul',
        description: 'Bloco sul da estaÃ§Ã£o Faria Lima',
        bimPath: 'projects/seed/estacao_faria_lima_bloco_sul.obj'
    }
];

// Dados mock para registros
const mockRecordNames = [
    'Semana 1 - Fachada Principal',
    'Semana 2 - Estrutura Interna',
    'Semana 3 - Plataforma',
    'Semana 4 - Acesso Norte',
    'Semana 5 - Acesso Sul',
    'Semana 6 - Escadas',
    'Semana 7 - Elevadores',
    'Semana 8 - FinalizaÃ§Ã£o'
];

// Status possÃ­veis para anÃ¡lises
const analysisStatuses = ['pending', 'processing', 'completed', 'failed'] as const;

/**
 * Criar diretÃ³rios necessÃ¡rios para arquivos mock
 */
function criarDiretoriosMock() {
    const uploadsDir = process.env.UPLOADS_DIR || './src/shared/data/uploads';
    const outputsDir = process.env.OUTPUTS_DIR || './src/shared/data/outputs';
    
    // Criar diretÃ³rios de projetos
    mockProjects.forEach((_, index) => {
        const projectId = index + 1;
        const projectUploadDir = path.join(uploadsDir, 'projects', projectId.toString());
        const projectOutputDir = path.join(outputsDir, projectId.toString());
        
        fs.mkdirSync(projectUploadDir, { recursive: true });
        fs.mkdirSync(projectOutputDir, { recursive: true });
        fs.mkdirSync(path.join(projectOutputDir, 'registros'), { recursive: true });
        fs.mkdirSync(path.join(projectOutputDir, 'analises'), { recursive: true });
    });
    
    // Criar diretÃ³rio seed
    const seedDir = path.join(uploadsDir, 'projects', 'seed');
    fs.mkdirSync(seedDir, { recursive: true });
    
    console.log('âœ… DiretÃ³rios criados');
}

/**
 * Criar arquivos BIM mock (arquivos vazios pequenos)
 */
function criarArquivosBimMock() {
    const uploadsDir = process.env.UPLOADS_DIR || './src/shared/data/uploads';
    
    mockProjects.forEach((project) => {
        const filePath = path.join(uploadsDir, project.bimPath);
        const dir = path.dirname(filePath);
        
        fs.mkdirSync(dir, { recursive: true });
        
        // Criar arquivo mock pequeno (apenas placeholder)
        fs.writeFileSync(filePath, `# Mock BIM file for ${project.name}\n# Generated by seed script\n`);
    });
    
    console.log('âœ… Arquivos BIM mock criados');
}

/**
 * Gerar caminhos de fotos mock
 */
function gerarCaminhosFotos(projectId: number, recordId: number, quantidade: number = 5): string[] {
    return Array.from({ length: quantidade }, (_, i) => 
        `projects/${projectId}/records/${recordId}/foto_${i + 1}.jpg`
    );
}

/**
 * Criar anÃ¡lise mock com status especÃ­fico
 */
function criarAnaliseMock(
    projectId: number,
    recordId: number,
    status: typeof analysisStatuses[number],
    index: number
) {
    const now = new Date();
    const baseData: any = {
        projectId,
        recordId,
        status,
        progress: 0,
        logs: [
            `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`,
            `  ğŸš€ ANÃLISE MOCK #${index + 1}`,
            `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`,
            ``,
            `ğŸ“¦ Projeto ID: ${projectId}`,
            `ğŸ“ Registro ID: ${recordId}`,
            `ğŸ“Š Status: ${status}`,
            ``
        ],
        outputPaths: {
            modelo3d: `${projectId}/registros/${recordId}/reconstrucao_${recordId}.ply`
        }
    };

    switch (status) {
        case 'pending':
            baseData.progress = 0;
            baseData.logs.push('â³ Aguardando processamento...');
            break;

        case 'processing':
            baseData.progress = Math.floor(Math.random() * 80) + 10; // 10-90%
            baseData.startedAt = new Date(now.getTime() - 5 * 60 * 1000); // 5 min atrÃ¡s
            baseData.logs.push(
                `ğŸ”„ Processamento em andamento...`,
                `ğŸ“Š Progresso: ${baseData.progress}%`,
                `[ReconstruÃ§Ã£o 3D] âœ… ConcluÃ­da`,
                `[ComparaÃ§Ã£o C2C] ğŸ”„ Em processamento...`
            );
            break;

        case 'completed':
            baseData.progress = 100;
            baseData.startedAt = new Date(now.getTime() - 10 * 60 * 1000); // 10 min atrÃ¡s
            baseData.completedAt = now;
            baseData.resultPath = `${projectId}/analises/analysis_${index + 1}/comparacao_c2c.ply`;
            baseData.summaryJsonPath = `${projectId}/analises/analysis_${index + 1}/summary_c2c.json`;
            baseData.meanDistance = parseFloat((Math.random() * 5 + 1).toFixed(2)); // 1-6mm
            baseData.stdDeviation = parseFloat((Math.random() * 3 + 0.5).toFixed(2)); // 0.5-3.5mm
            baseData.logs.push(
                `âœ… Processamento concluÃ­do com sucesso!`,
                `ğŸ“Š MÃ©tricas:`,
                `   â€¢ DistÃ¢ncia mÃ©dia: ${baseData.meanDistance}mm`,
                `   â€¢ Desvio padrÃ£o: ${baseData.stdDeviation}mm`,
                `ğŸ“ Arquivos gerados:`,
                `   â€¢ ${baseData.resultPath}`,
                `   â€¢ ${baseData.summaryJsonPath}`
            );
            break;

        case 'failed':
            baseData.progress = Math.floor(Math.random() * 60) + 20; // 20-80%
            baseData.startedAt = new Date(now.getTime() - 3 * 60 * 1000); // 3 min atrÃ¡s
            baseData.error = 'Erro ao processar imagens: Falha na detecÃ§Ã£o de features';
            baseData.logs.push(
                `âŒ Processamento falhou`,
                `âš ï¸ Erro: ${baseData.error}`,
                `ğŸ“Š Progresso alcanÃ§ado: ${baseData.progress}%`
            );
            break;
    }

    return baseData;
}

/**
 * FunÃ§Ã£o principal de seed
 */
async function main() {
    console.log('ğŸŒ± Iniciando seed do banco de dados...\n');

    try {
        // Limpar banco (opcional - descomente se quiser resetar)
        // console.log('ğŸ—‘ï¸  Limpando banco de dados...');
        // await prisma.analysis.deleteMany();
        // await prisma.record.deleteMany();
        // await prisma.project.deleteMany();
        // console.log('âœ… Banco limpo\n');

        // Criar diretÃ³rios e arquivos mock
        console.log('ğŸ“ Criando estrutura de diretÃ³rios...');
        criarDiretoriosMock();
        criarArquivosBimMock();
        console.log('');

        // Criar projetos
        console.log('ğŸ“¦ Criando projetos...');
        const projetos = [];
        for (const projectData of mockProjects) {
            try {
                const projeto = await prisma.project.create({
                    data: projectData
                });
                projetos.push(projeto);
                console.log(`   âœ“ ${projeto.name} (ID: ${projeto.id})`);
            } catch (error: any) {
                if (error.code === 'P2002') {
                    // Projeto jÃ¡ existe, buscar existente
                    const existente = await prisma.project.findUnique({
                        where: { bimPath: projectData.bimPath }
                    });
                    if (existente) {
                        projetos.push(existente);
                        console.log(`   âš ï¸  ${projectData.name} jÃ¡ existe (ID: ${existente.id})`);
                    }
                } else {
                    throw error;
                }
            }
        }
        console.log(`âœ… ${projetos.length} projetos criados\n`);

        // Criar registros para cada projeto
        console.log('ğŸ“ Criando registros...');
        const registros: any[] = [];
        
        for (let i = 0; i < projetos.length; i++) {
            const projeto = projetos[i];
            const quantidadeRegistros = Math.floor(Math.random() * 3) + 2; // 2-4 registros por projeto
            
            for (let j = 0; j < quantidadeRegistros; j++) {
                const recordName = mockRecordNames[j % mockRecordNames.length];
                const fotosPaths = gerarCaminhosFotos(projeto.id, j + 1, 5);
                
                const record = await prisma.record.create({
                    data: {
                        name: `${recordName} - Projeto ${projeto.id}`,
                        projectId: projeto.id,
                        uploadedFilesPaths: fotosPaths,
                        recordPath: j % 2 === 0 
                            ? `${projeto.id}/registros/${j + 1}/reconstrucao_${j + 1}.ply`
                            : null // Alguns registros sem reconstruÃ§Ã£o ainda
                    }
                });
                
                registros.push({ ...record, projectId: projeto.id });
                console.log(`   âœ“ ${record.name} (ID: ${record.id}, Projeto: ${projeto.id})`);
            }
        }
        console.log(`âœ… ${registros.length} registros criados\n`);

        // Criar anÃ¡lises com diferentes status
        console.log('ğŸ“Š Criando anÃ¡lises...');
        let analysisCount = 0;
        
        for (const registro of registros) {
            // Criar 1-2 anÃ¡lises por registro
            const quantidadeAnalises = Math.floor(Math.random() * 2) + 1;
            
            for (let k = 0; k < quantidadeAnalises; k++) {
                const statusIndex = analysisCount % analysisStatuses.length;
                const status = analysisStatuses[statusIndex];
                
                const analysisData = criarAnaliseMock(
                    registro.projectId,
                    registro.id,
                    status,
                    analysisCount
                );
                
                const analysis = await prisma.analysis.create({
                    data: analysisData
                });
                
                analysisCount++;
                console.log(`   âœ“ AnÃ¡lise #${analysis.id} - Status: ${status} (Projeto: ${registro.projectId}, Registro: ${registro.id})`);
            }
        }
        console.log(`âœ… ${analysisCount} anÃ¡lises criadas\n`);

        // EstatÃ­sticas finais
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ğŸ“Š EstatÃ­sticas do Seed:');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        const totalProjects = await prisma.project.count();
        const totalRecords = await prisma.record.count();
        const totalAnalyses = await prisma.analysis.count();
        
        const analysesByStatus = await prisma.analysis.groupBy({
            by: ['status'],
            _count: true
        });
        
        console.log(`ğŸ“¦ Projetos: ${totalProjects}`);
        console.log(`ğŸ“ Registros: ${totalRecords}`);
        console.log(`ğŸ“Š AnÃ¡lises: ${totalAnalyses}`);
        console.log('');
        console.log('ğŸ“ˆ AnÃ¡lises por status:');
        analysesByStatus.forEach(({ status, _count }) => {
            console.log(`   â€¢ ${status}: ${_count}`);
        });
        
        console.log('');
        console.log('âœ… Seed concluÃ­do com sucesso!');
        console.log('');
        console.log('ğŸ’¡ PrÃ³ximos passos:');
        console.log('   1. Inicie o servidor: npm run dev');
        console.log('   2. Teste a API: curl http://localhost:3000/api/projects');
        console.log('   3. Veja anÃ¡lises: curl http://localhost:3000/api/analyses');
        
    } catch (error) {
        console.error('âŒ Erro durante seed:', error);
        throw error;
    } finally {
        await prisma.$disconnect();
    }
}

// Executar seed
main()
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

